* `file`: Requerido. Un `file` abierto en modo binario para analizar o una ruta expresada como un `str` o un objeto `PathLike`
  que especifica dónde está el archivo a analizar.

* `threshold`: Un `float` entre `0.0` y `1.0`, inclusive, que sirve como límite para determinar qué cuadros delimitadores del archivo se devuelven o una cadena `auto` (el valor predeterminado) donde el servicio utiliza un método de procesamiento para encontrar la mejor predicción para cada posible cuadro delimitador.
  Solo se devolverán los cuadros delimitadores que el modelo predice con una puntuación de confianza superior al umbral especificado. Un valor más bajo
  incluirá más objetos pero puede tener superposiciones, mientras que un valor más alto reducirá el número de superposiciones pero puede perder objetos legítimos. Si
  establece el umbral manualmente, recomendamos comenzar con un valor de `0.32`.

* `extract_table_structure`: Un booleano que, cuando es `True`, permite a DocParse extraer tablas y su contenido
  estructural utilizando un modelo de extracción de tablas diseñado para este propósito. Si se establece en `False`, las tablas aún se identifican pero
  no se analizan para su estructura; como resultado, las celdas de la tabla y sus cuadros delimitadores no se incluyen en la respuesta.
  El valor predeterminado es `False`.

* `text_mode`: Una cadena que especifica el modo a utilizar para la extracción de texto. El valor predeterminado es `standard`, que extrae el texto incrustado. Las otras opciones son `fine_grained`, que extrae el texto incrustado de una manera más detallada, `standard_ocr` que utiliza el pipeline de OCR clásico, y `vision_ocr` que utiliza un modelo de visión para OCR.
  Tenga en cuenta que `vision_ocr` solo está disponible para usuarios de PAYG.

* `text_extraction_options`: Un mapa con claves de cadena que especifica opciones para la extracción de texto.
  * `ocr_text_mode` (obsoleto): Una cadena que especifica el modo a utilizar para la extracción de texto OCR. El valor predeterminado es `standard`, que utiliza el pipeline de OCR clásico convencional para procesar documentos. La otra opción es `vision`, que utiliza un modelo de visión para OCR. Tenga en cuenta que `vision` solo está disponible para usuarios de PAYG.
  * `remove_line_breaks`: Un booleano que especifica si se deben eliminar los saltos de línea del texto. El valor predeterminado es `False`.

* `table_extraction_options`: Un mapa con claves de cadena que especifica opciones para la extracción de tablas. Solo se aplica cuando `extract_table_structure` es `True`. El valor predeterminado es vacío (`{}`)
  * `include_additional_text`: Booleano. Cuando es `True`, DocParse intentará mejorar la estructura de la tabla fusionando tokens de la extracción de texto. Esto puede ser útil para trabajar con tablas que tienen texto faltante o mal alineado. El valor predeterminado es `False`
  * `model_selection`: Cadena. Una expresión para instruir a DocParse sobre cómo seleccionar el modelo de tabla a utilizar para la extracción. El valor predeterminado es `"pixels > 500 -> deformable_detr; table_transformer"`, que significa "si la dimensión más grande de la tabla es más de 500 píxeles, use deformable\_detr; de lo contrario, use table\_transformer." Para usar solo deformable\_detr o table\_transformer, establezca `model_selection="deformable_detr"` o `model_selection="table_transformer"`. Las expresiones de selección tienen la forma

    ```
    metric cmp threshold -> model; metric cmp threshold -> model; model
    ```

    Y debe leerse como una serie de `if metric compares to threshold, then use model` declaraciones. Las declaraciones se procesan de izquierda a derecha.

    * Los modelos soportados son `table_transformer`, que tiende a funcionar bien con tablas más pequeñas, y `deformable_detr`, que tiende a funcionar mejor con tablas más grandes.
    * Las métricas soportadas son `pixels`, que corresponde a la dimensión máxima del cuadro delimitador que contiene la tabla (encontramos que esto es más fácil de razonar que el número total de píxeles que depende de dos números), y `chars`, que corresponde al número total de caracteres dentro de la tabla según lo determinado por el paso de OCR/extracción de texto.
    * Los umbrales deben ser numéricos.
    * Los operadores de comparación soportados son `<, >, <=, >=, ==, !=`.

    Una declaración sin métrica, comparación y umbral puede considerarse como predeterminada, donde las declaraciones después de la predeterminada no se procesarán. Si no se incluye tal declaración 'incondicional' y no coincide ninguna condición, DocParse utilizará por defecto table\_transformer. Cualquier cosa después de la declaración incondicional no se procesará.
    Ejemplos:

    * `table_transformer` => siempre usar table transformer
    * `pixels > 500 -> deformable_detr; table_transformer` => si la dimensión más grande de la tabla es mayor que 500 píxeles, usar deformable detr. De lo contrario, usar table\_transformer.
    * `pixels>50->table_transformer; chars<30->deformable_detr;chars>35->table_transformer;pixels>2->deformable_detr;table_transformer;comment` => si la dimensión más grande es más de 50 píxeles, usar table transformer. Si no, si el número total de caracteres en la tabla es menor que 30, usar deformable\_detr. Si no, si hay más de 35 caracteres, usar table transformer. Si no, si hay más de 2 píxeles en la dimensión más grande, usar deformable detr. De lo contrario, usar table transformer. El comentario no se procesa.

* `extract_images`: Un booleano que determina si se deben extraer imágenes del documento. El formato está determinado por el valor de `extract_image_format`. Por defecto: `False`.

* `extract_image_format`: Una cadena que indica en qué formato se deben devolver las imágenes extraídas. Debe ser uno de `ppm`, `png`, o `jpeg`. En todos los casos, el resultado se codificará en base64 antes de ser devuelto. Por defecto: `ppm`.

* `summarize_images`: (Solo PAYG) Un booleano que, cuando es `True`, genera un resumen de las imágenes en el documento y lo devuelve como el `text_representation`. Cuando es `False`, las imágenes no se resumen. El valor predeterminado es `False`.

* `selected_pages`: Una lista que especifica páginas individuales (indexadas desde 1) y rangos de páginas del documento para particionar.
  Las páginas individuales se especifican como enteros y los rangos se especifican como listas con dos entradas enteras en orden ascendente. Un
  ejemplo válido de valor para selected\_pages es `[1, 10, [15, 20]]` que incluiría las páginas 1, 10, 15, 16, 17 ..., 20.
  `selected_pages` es `None` por defecto, lo que resulta en que se analicen todas las páginas del documento.

* `chunking_options`: Un diccionario de opciones para especificar el comportamiento de fragmentación. La fragmentación solo se realiza cuando esta
  opción está presente, y se eligen opciones predeterminadas cuando `chunking_options` se especifica como `{}`.
  * `strategy`: Una cadena que especifica la estrategia a utilizar para combinar y dividir fragmentos. Los valores válidos son `context_rich`
    y `maximize_within_limit`. El fragmentador predeterminado y recomendado es `context_rich` como
    `{'strategy': 'context_rich'}`.
    * Comportamiento de `context_rich` chunker: The goal of this strategy is to add context to evenly-sized chunks. This
      is most useful for retrieval based GenAI applications. Context\_rich chunking combines adjacent `section-header`
      y `title` elementos en un nuevo `section-header` elemento. Fusiona elementos en un fragmento con su más reciente
      `section-header`. Si el fragmento contendría demasiados tokens, entonces comienza un nuevo fragmento copiando el
      encabezado de sección al inicio de este nuevo fragmento y continúa. Fusiona elementos en diferentes páginas, a menos que
      `merge_across_pages` esté configurado como `False`.
    * Comportamiento del fragmentador `maximize_within_limit` chunker: The goal of the `maximize_within_limit` es hacer los
      fragmentos tan grandes como sea posible. Fusiona elementos en el conjunto de elementos fusionados más recientemente a menos que hacerlo
      haga que su recuento de tokens exceda `max_tokens`. En ese caso, mantendría el nuevo elemento separado y comenzaría
      a fusionar los elementos subsiguientes en ese, siguiendo la misma regla. Fusiona elementos en diferentes páginas, a menos que
      `merge_across_pages` esté configurado como `False`.
  * `max_tokens`: Un entero que especifica el límite para dividir fragmentos que son demasiado grandes. El valor predeterminado es 512.
  * `tokenizer`: Una cadena que especifica el tokenizador a utilizar al determinar cómo se agrupan los caracteres en un fragmento.
    Los valores válidos son `openai_tokenizer`, `character_tokenizer`, y `huggingface_tokenizer`. Por defecto es `openai_tokenizer`.
  * `tokenizer_options`: Un diccionario anidado con claves de cadena que especifica las opciones para el tokenizador elegido. Por defecto es
    `{'model_name': 'text-embedding-3-small'}`, que funciona con el tokenizador de OpenAI.
    * Opciones disponibles para `openai_tokenizer`:
      * `model_name`: Acepta todos los modelos soportados por el
        [tokenizador tiktoken de OpenAI](https://github.com/openai/tiktoken). El valor predeterminado es "text-embedding-3-small"
    * Opciones disponibles para `HuggingFaceTokenizer`:
      * `model_name`: Acepta todos los tokenizadores de huggingface del
        [repositorio huggingface/tokenizers](https://github.com/huggingface/tokenizers).
    * `character_tokenizer` no toma ninguna opción.
  * `merge_across_pages`: Un `boolean` que cuando es `True` el fragmentador seleccionado intentará fusionar fragmentos a través de los límites de página.
    No se aplica al fusionador `mixed_multi_column`, que nunca fusiona a través de páginas. Por defecto es
    `True`.

* `output_format`: Una cadena que controla la representación de salida. Por defecto es `json` que produce un array llamado
  `elements` que contiene los elementos particionados, representados en JSON. Si se establece en `markdown` la respuesta del servicio
  en su lugar incluirá un campo llamado `markdown` que contiene una cadena que representa todo el documento en formato Markdown.

* `output_label_options`: Un diccionario de opciones para especificar qué heurística aplicar para forzar ciertas salidas de etiquetas. Si esta opción no se especifica, no se aplica ninguna heurística. Las opciones que soporta el diccionario se enumeran a continuación.
  * `promote_title`: Un booleano que especifica si se debe promover un elemento a título si no hay título en la salida.
  * `title_candidate_elements`: Una lista de cadenas que son elementos candidatos para ser promovidos a título.
  * `orientation_correction`: Un valor booleano que especifica si se debe corregir la orientación de las páginas rotadas durante el paso de preprocesamiento.

* `markdown_options`: Un diccionario de opciones para especificar qué incluir en la salida de markdown.
  * `include_pagenum`: Un booleano que especifica si se deben incluir los números de página en la salida de markdown. El valor predeterminado es `False`.
  * `include_headers`: Un booleano que especifica si se deben incluir los encabezados en la salida de markdown. El valor predeterminado es `False`.
  * `include_footers`: Un booleano que especifica si se deben incluir los pies de página en la salida de markdown. El valor predeterminado es `False`.

* `ssl_verify`: Un `boolean` que controla si el cliente verifica el certificado SSL del servidor DocParse
  elegido. ssl\_verify es `True` por defecto, aplicando la verificación SSL.

* `aryn_config`: Un objeto ArynConfig (definido en
  [aryn\_sdk/config.py](https://github.com/aryn-ai/sycamore/blob/main/lib/aryn-sdk/aryn_sdk/config.py)), utilizado para encontrar
  una clave de API. Si aryn\_api\_key está establecido, anulará esto. El ArynConfig predeterminado busca en la variable de entorno `ARYN_API_KEY`y luego en el archivo \~/.aryn/config.yaml. El valor predeterminado es None (aryn-sdk buscará en el parámetro aryn\_api\_key, en sus variables de entorno, y luego en \~/.aryn/config.yaml).

* `aryn_api_key`: Una clave API de Aryn, proporcionada como una cadena. Puede obtener una gratis en [aryn.ai/get-started](https://www.aryn.ai/get-started). El valor predeterminado es `None` (Si no se proporciona, el sdk la buscará en la variable de entorno `ARYN_API_KEY` o buscará en aryn\_config como se especificó anteriormente).

* `use_ocr` (obsoleto): Un valor booleano que, cuando se establece en `True`, hace que DocParse extraiga texto usando un modelo OCR. Esto es útil cuando el texto no es directamente extraíble del PDF, como cuando el texto es parte de una imagen o cuando el texto está rotado. Cuando se establece en `False`, DocParse extrae el texto incrustado del documento de entrada. El valor predeterminado es `False`.
